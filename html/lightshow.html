<!DOCTYPE html>
<html>

<head>
    <title>GPU Shadow</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <!-- Loading status overlay -->
    <div id="loadingStatus" style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(30,30,40,0.95);color:#fff;padding:22px 38px 22px 32px;border-radius:16px;box-shadow:0 2px 24px #000a;font-family:monospace;font-size:1.2rem;z-index:100;user-select:none;">Loading assets...</div>
    <!-- core three.js -->
    <div style="position:fixed;top:12px;left:16px;z-index:32;display:flex;align-items:center;gap:10px;">
        <div id="hint" style="color:#fff;background:rgba(0,0,0,0.5);padding:7px 16px 7px 12px;border-radius:10px;font-family:monospace;font-size:1.05rem;pointer-events:none;user-select:none;display:inline-block;">Rotate: <b>A</b> / <b>D</b></div>
        <button id="toggleOverlay" style="background:#222a38;color:#fff;border:none;padding:7px 18px 7px 18px;border-radius:10px;font-family:monospace;font-size:1.05rem;box-shadow:0 2px 8px #0005;cursor:pointer;">‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏ú‡∏á‡∏Ñ‡∏≠‡∏ô‡πÇ‡∏ó‡∏£‡∏•‡πÑ‡∏ü</button>
        <button id="speakerBtn" style="background:#222a38;color:#fff;border:none;padding:7px 14px 7px 14px;border-radius:10px;font-family:monospace;font-size:1.2rem;box-shadow:0 2px 8px #0005;cursor:pointer;display:flex;align-items:center;gap:4px;" title="Mute/Unmute"><span id="speakerIcon">üîä</span></button>
    </div>
    <!-- Audio element for music -->
    <audio id="bgmAudio" src="https://wshlcodelabs.github.io/CG-Gallery/html/assets/music/krabazing.mp3" preload="auto" loop style="display:none;"></audio>

    <script>
    // === Speaker/Mute logic ===
    const speakerBtn = document.getElementById('speakerBtn');
    const speakerIcon = document.getElementById('speakerIcon');
    const bgmAudio = document.getElementById('bgmAudio');
    let isMuted = false;
    let fadeInterval = null;

    function fadeInAudio(audio, duration = 2000) {
        audio.volume = 0;
        audio.play();
        if (fadeInterval) clearInterval(fadeInterval);
        fadeInterval = setInterval(() => {
            if (audio.volume < 0.99) {
                audio.volume = Math.min(audio.volume + 0.04, 1);
            } else {
                audio.volume = 1;
                clearInterval(fadeInterval);
            }
        }, duration / 25);
    }

    function fadeOutAudio(audio, duration = 800) {
        if (fadeInterval) clearInterval(fadeInterval);
        fadeInterval = setInterval(() => {
            if (audio.volume > 0.04) {
                audio.volume = Math.max(audio.volume - 0.04, 0);
            } else {
                audio.volume = 0;
                audio.pause();
                clearInterval(fadeInterval);
            }
        }, duration / 25);
    }

    function setSpeakerState(muted) {
        isMuted = muted;
        if (isMuted) {
            fadeOutAudio(bgmAudio);
            speakerIcon.textContent = 'üîá';
        } else {
            fadeInAudio(bgmAudio);
            speakerIcon.textContent = 'üîä';
        }
    }

    speakerBtn.addEventListener('click', () => {
        setSpeakerState(!isMuted);
    });

    // Start music on first user interaction (required by browsers)
    let musicStarted = false;
    let assetLoaded = false;
    let userInteracted = false;
    function tryStartMusic() {
        if (!musicStarted && assetLoaded && userInteracted) {
            setSpeakerState(false);
            musicStarted = true;
        }
    }
    // Listen for any user interaction to start music
    function handleUserInteraction() {
        userInteracted = true;
        tryStartMusic();
    }
    window.addEventListener('pointerdown', handleUserInteraction, { once: true });
    // Also trigger on first click/tap of overlay or speaker button (for mobile)
    toggleOverlayBtn.addEventListener('click', handleUserInteraction, { once: true });
    speakerBtn.addEventListener('click', handleUserInteraction, { once: true });
    </script>
    <!-- Light Show Control Panel -->
    <div id="light-panel" style="position:fixed;top:60px;left:16px;z-index:20;background:rgba(30,30,40,0.92);color:#fff;padding:18px 22px 18px 18px;border-radius:14px;box-shadow:0 2px 16px #0008;font-family:monospace;min-width:260px;user-select:none;display:none;">
        <div style="font-size:1.1rem;font-weight:bold;margin-bottom:8px;">üó£Ô∏èüî•üî•Lighting Control</div>
        <label>Lights: <input id="numLights" type="range" min="1" max="12" value="5" style="width:90px;vertical-align:middle;"><span id="numLightsVal">5</span></label><br>
        <label>Pattern:
            <select id="patternSel">
                <option value="orbit">Orbit</option>
                <option value="sweep" selected>Sweep</option>
                <option value="random">Random</option>
                <option value="pulse">Pulse</option>
                <option value="zigzag">Zigzag</option>
                <option value="spiral">Spiral</option>
                <option value="wave">Wave</option>
            </select>
        </label><br>
        <label>Color:
            <select id="colorSel">
                <option value="rainbow">Rainbow</option>
                <option value="white">White</option>
                <option value="random" selected>Random</option>
                <option value="custom">Custom</option>
                <option value="pastel">Pastel</option>
                <option value="neon">Neon</option>
            </select>
        </label><br>
        <label>Speed: <input id="speedRange" type="range" min="0.1" max="6" step="0.01" value="1.5" style="width:90px;vertical-align:middle;"><span id="speedVal">1.50</span></label><br>
        <label>Brightness: <input id="intensityRange" type="range" min="0.1" max="5" step="0.01" value="2.2" style="width:90px;vertical-align:middle;"><span id="intensityVal">2.20</span></label><br>
        <div id="customColors" style="margin-top:8px;display:none;"></div>
    </div>

    <!-- Minimap overlay -->
    <canvas id="minimap" width="180" height="180" style="position:fixed;right:24px;top:24px;z-index:30;background:rgba(20,20,30,0.92);border-radius:12px;box-shadow:0 2px 12px #0007;display:none;"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>

    <script>

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // ‚úÖ ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÄ‡∏á‡∏≤!
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();

        // ‚úÖ ‡∏Å‡∏•‡πâ‡∏≠‡∏á
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        // Camera orbit variables
        let camRadius = 5;
        let camAngle = 0;
        const camY = 2;
        function updateCamera() {
            camera.position.x = Math.sin(camAngle) * camRadius;
            camera.position.z = Math.cos(camAngle) * camRadius;
            camera.position.y = camY;
            camera.lookAt(0, 0.7, 0); // look at slightly above ground for chair
        }
        updateCamera();

        // Remove static directional light, add dynamic spotlights for the show
        // Dynamic Light Show Variables
let spotLights = [];
let spotHelpers = [];
let numLights = 5;
let lightPattern = 'sweep';
let colorPattern = 'random';
let speed = 1.5;
let intensity = 2.2;
let customColors = ['#ffffff', '#ffffff', '#ffffff', '#ffffff', '#ffffff', '#ffffff', '#ffffff', '#ffffff', '#ffffff', '#ffffff', '#ffffff', '#ffffff'];

function createSpotLights(n) {
    // Remove old lights
    spotLights.forEach(l => scene.remove(l));
    spotHelpers.forEach(h => scene.remove(h));
    spotLights = [];
    spotHelpers = [];
    for (let i = 0; i < n; i++) {
        const spot = new THREE.SpotLight(0xffffff, intensity, 20, Math.PI/7, 0.25, 1.2);
        spot.castShadow = true;
        spot.shadow.mapSize.width = 1024;
        spot.shadow.mapSize.height = 1024;
        spot.shadow.camera.near = 0.5;
        spot.shadow.camera.far = 30;
        scene.add(spot);
        // Optionally add helpers for debugging
        // const helper = new THREE.SpotLightHelper(spot);
        // scene.add(helper);
        // spotHelpers.push(helper);
        spotLights.push(spot);
    }
}
        createSpotLights(numLights);



        // ‚úÖ Ambient Light ‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÉ‡∏´‡πâ‡∏™‡∏ß‡πà‡∏≤‡∏á‡∏£‡∏ß‡∏°
        const ambient = new THREE.AmbientLight(0x222233, 0.7);
        scene.add(ambient);



        // ‚úÖ ‡∏û‡∏∑‡πâ‡∏ô
        const planeGeometry = new THREE.PlaneGeometry(10, 10);
        const planeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2; // ‡∏´‡∏°‡∏∏‡∏ô‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏∑‡πâ‡∏ô
        plane.position.y = 0;
        plane.receiveShadow = true; // ‚úÖ ‡∏û‡∏∑‡πâ‡∏ô‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏≤
        scene.add(plane);




        // ‚úÖ ‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á OBJ
        let chairMesh = null;
        const objLoader = new THREE.OBJLoader();
        const loadingStatus = document.getElementById('loadingStatus');
        objLoader.load(
            'https://wshlcodelabs.github.io/CG-Gallery/html/assets/obj/chair_v2.obj',
            function (object) {
                // Center the object
                const box = new THREE.Box3().setFromObject(object);
                const center = box.getCenter(new THREE.Vector3());
                object.position.sub(center); // Center at (0,0,0)
                object.position.y += (box.max.y - box.min.y) / 2;
                // Enable shadow and store mesh reference
                object.traverse(function(child) {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        // Replace material with MeshStandardMaterial for color animation
                        child.material = new THREE.MeshStandardMaterial({ color: 0xffffff });
                        chairMesh = child;
                    }
                });
                scene.add(object);
                // Hide loading status when done
                if (loadingStatus) loadingStatus.style.display = 'none';
                // Mark asset as loaded and try to start music
                assetLoaded = true;
                tryStartMusic();
            },
            function(xhr) {
                // Progress callback (xhr.loaded, xhr.total)
                if (loadingStatus && xhr.lengthComputable) {
                    let percent = Math.floor((xhr.loaded / xhr.total) * 100);
                    loadingStatus.textContent = `Loading assets... (${percent}%)`;
                }
            },
            function (error) {
                if (loadingStatus) loadingStatus.textContent = 'Failed to load assets!';
                console.error('An error happened loading the OBJ:', error);
            }
        );

        // === Light Show Animation Patterns ===
function getLightColor(i, t) {
    if (colorPattern === 'rainbow') {
        // Rainbow color cycling
        const hue = ((t * 0.08 * speed + i / numLights) % 1.0);
        const color = new THREE.Color();
        color.setHSL(hue, 0.85, 0.55);
        return color;
    } else if (colorPattern === 'white') {
        return new THREE.Color(0xffffff);
    } else if (colorPattern === 'random') {
        // Flicker random color
        return new THREE.Color(Math.random(), Math.random(), Math.random());
    } else if (colorPattern === 'custom') {
        return new THREE.Color(customColors[i % customColors.length]);
    } else if (colorPattern === 'pastel') {
        // Pastel colors
        const pastelHues = [0.05, 0.12, 0.18, 0.33, 0.58, 0.72, 0.85];
        const hue = pastelHues[i % pastelHues.length];
        const color = new THREE.Color();
        color.setHSL(hue, 0.5, 0.8);
        return color;
    } else if (colorPattern === 'neon') {
        // Neon colors
        const neonColors = [0x39ff14, 0xff073a, 0x00f0ff, 0xfffb00, 0xff00de, 0x00ff85];
        return new THREE.Color(neonColors[i % neonColors.length]);
    }
    return new THREE.Color(0xffffff);
}

        // Scatter spotlights more widely and randomize their targets
        // Precompute random target offsets for each light
        let spotTargetOffsets = [];
        function updateSpotTargetOffsets() {
            spotTargetOffsets = [];
            for (let i = 0; i < numLights; i++) {
                // Scatter target points within a region around the chair
                const tx = (Math.random() - 0.5) * 6; // -3 to 3
                const tz = (Math.random() - 0.5) * 6; // -3 to 3
                const ty = 0.7 + (Math.random() - 0.5) * 1.2; // 0.1 to 1.3
                spotTargetOffsets.push({ x: tx, y: ty, z: tz });
            }
        }
        // Update offsets whenever number of lights changes
        const origCreateSpotLights = createSpotLights;
        createSpotLights = function(n) {
            origCreateSpotLights(n);
            updateSpotTargetOffsets();
        };
        updateSpotTargetOffsets();

function updateSpotLights(t) {
    // Increase scatter radius
    const scatterRadius = 7.5;
    for (let i = 0; i < spotLights.length; i++) {
        const spot = spotLights[i];
        // Movement patterns
        let x = 0, y = 0, z = 0;
        if (lightPattern === 'orbit') {
            const angle = t * 0.001 * speed + (i * 2 * Math.PI / spotLights.length);
            x = Math.cos(angle) * scatterRadius + (Math.sin(angle * 1.7 + i) * 1.5);
            z = Math.sin(angle) * scatterRadius + (Math.cos(angle * 1.3 + i) * 1.5);
            y = 4.5 + Math.sin(angle * 1.5 + i) * 2.2;
        } else if (lightPattern === 'sweep') {
            x = Math.sin(t * 0.001 * speed + i) * scatterRadius + Math.cos(i * 2) * 2.2;
            z = Math.cos(i) * scatterRadius + Math.sin(i * 2) * 2.2;
            y = 4.5 + Math.cos(t * 0.001 * speed * 1.5 + i) * 2.2;
        } else if (lightPattern === 'random') {
            x = Math.sin(t * 0.001 * speed * (1.2 + i)) * scatterRadius + Math.random() * 1.2;
            z = Math.cos(t * 0.001 * speed * (1.1 + i)) * scatterRadius + Math.random() * 1.2;
            y = 4.5 + Math.sin(t * 0.001 * speed * (1.3 + i)) * 2.2 + Math.random() * 1.2;
        } else if (lightPattern === 'pulse') {
            const base = Math.sin(t * 0.001 * speed + i) * 4.5;
            x = Math.cos(i) * (4.5 + base);
            z = Math.sin(i) * (4.5 + base);
            y = 4.5 + Math.abs(base) * 1.2;
        } else if (lightPattern === 'zigzag') {
            x = ((i % 2 === 0) ? 1 : -1) * Math.abs(Math.sin(t * 0.001 * speed + i)) * scatterRadius * 0.9;
            z = Math.cos(i) * scatterRadius * 0.7 + Math.sin(t * 0.001 * speed * 1.2 + i) * 2.2;
            y = 4.5 + Math.abs(Math.sin(t * 0.001 * speed * 1.5 + i)) * 2.2;
        } else if (lightPattern === 'spiral') {
            const angle = t * 0.001 * speed + (i * 2 * Math.PI / spotLights.length);
            const spiral = (i + 1) / spotLights.length * scatterRadius;
            x = Math.cos(angle) * spiral;
            z = Math.sin(angle) * spiral;
            y = 4.5 + spiral * 0.7 + Math.sin(angle * 2.2 + i) * 1.2;
        } else if (lightPattern === 'wave') {
            x = Math.sin(t * 0.001 * speed + i) * scatterRadius * 0.8;
            z = Math.cos(i) * scatterRadius * 0.8;
            y = 4.5 + Math.sin(t * 0.001 * speed * 2 + i) * 2.5;
        }
        spot.position.set(x, y, z);
        // Scatter target points, not always at chair
        let target = spotTargetOffsets[i] || { x: 0, y: 0.7, z: 0 };
        spot.target.position.set(target.x, target.y, target.z);
        spot.target.updateMatrixWorld();
        spot.color = getLightColor(i, t * 0.001);
    }
}

        // === Minimap logic ===
        const minimap = document.getElementById('minimap');
        const mctx = minimap.getContext('2d');
        const mapSize = 180;
        const planeSize = 10; // matches plane geometry
        let overlayVisible = false;
        // Hide panel and minimap by default
        document.getElementById('light-panel').style.display = 'none';
        minimap.style.display = 'none';
        function worldToMap(x, z) {
            // Map world x,z (-planeSize/2..planeSize/2) to minimap (10px..170px)
            const px = ((x + planeSize/2) / planeSize) * (mapSize-20) + 10;
            const pz = ((z + planeSize/2) / planeSize) * (mapSize-20) + 10;
            return {x: px, y: mapSize - pz}; // invert y for canvas
        }
        function drawMinimap() {
            if (!overlayVisible) return;
            mctx.clearRect(0,0,mapSize,mapSize);
            // Draw plane outline
            mctx.save();
            mctx.strokeStyle = '#aaa';
            mctx.lineWidth = 2;
            mctx.beginPath();
            mctx.rect(10,10,mapSize-20,mapSize-20);
            mctx.stroke();
            // Draw chair at center
            mctx.beginPath();
            mctx.arc(mapSize/2, mapSize/2, 8, 0, 2*Math.PI);
            mctx.fillStyle = '#8888ff';
            mctx.fill();
            mctx.strokeStyle = '#4444aa';
            mctx.lineWidth = 1.5;
            mctx.stroke();
            // Draw spotlights
            for (let i = 0; i < spotLights.length; i++) {
                const spot = spotLights[i];
                const pos = worldToMap(spot.position.x, spot.position.z);
                mctx.beginPath();
                mctx.arc(pos.x, pos.y, 7, 0, 2*Math.PI);
                // Use same color as light
                mctx.fillStyle = '#' + spot.color.getHexString();
                mctx.globalAlpha = 0.85;
                mctx.fill();
                mctx.globalAlpha = 1.0;
                mctx.strokeStyle = '#fff';
                mctx.lineWidth = 1.2;
                mctx.stroke();
                // Draw a line to target
                const tgt = spot.target.position;
                const tgtPos = worldToMap(tgt.x, tgt.z);
                mctx.beginPath();
                mctx.moveTo(pos.x, pos.y);
                mctx.lineTo(tgtPos.x, tgtPos.y);
                mctx.strokeStyle = '#fff6';
                mctx.lineWidth = 1;
                mctx.stroke();
            }
            mctx.restore();
        }

        // Overlay toggle button logic
        const toggleOverlayBtn = document.getElementById('toggleOverlay');
        toggleOverlayBtn.addEventListener('click', () => {
        overlayVisible = !overlayVisible;
        minimap.style.display = overlayVisible ? '' : 'none';
        document.getElementById('light-panel').style.display = overlayVisible ? '' : 'none';
        toggleOverlayBtn.textContent = overlayVisible ? '‡∏õ‡∏¥‡∏î‡πÅ‡∏ú‡∏á‡∏Ñ‡∏≠‡∏ô‡πÇ‡∏ó‡∏£‡∏•‡πÑ‡∏ü' : '‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏ú‡∏á‡∏Ñ‡∏≠‡∏ô‡πÇ‡∏ó‡∏£‡∏•‡πÑ‡∏ü';
        });

        // Animate chair color in sync with lights, and update minimap
        function animate(t) {
            updateSpotLights(t);
            if (chairMesh && chairMesh.material) {
                // Use first light color for chair
                const c = getLightColor(0, t * 0.001);
                chairMesh.material.color.copy(c);
            }
            renderer.render(scene, camera);
            drawMinimap();
            requestAnimationFrame(animate);
        }
        animate(0);

        window.addEventListener('keydown', (event) => {
            if (event.key === 'a' || event.key === 'A') {
                camAngle -= 0.12;
                updateCamera();
            } else if (event.key === 'd' || event.key === 'D') {
                camAngle += 0.12;
                updateCamera();
            }
        });

        // === Control Panel Logic ===
        const numLightsInput = document.getElementById('numLights');
        const numLightsVal = document.getElementById('numLightsVal');
        const patternSel = document.getElementById('patternSel');
        const colorSel = document.getElementById('colorSel');
        const speedRange = document.getElementById('speedRange');
        const speedVal = document.getElementById('speedVal');
        const customColorsDiv = document.getElementById('customColors');

        numLightsInput.addEventListener('input', () => {
            numLights = parseInt(numLightsInput.value);
            numLightsVal.textContent = numLights;
            createSpotLights(numLights);
            updateCustomColorInputs();
        });
        patternSel.addEventListener('change', () => {
            lightPattern = patternSel.value;
        });
        colorSel.addEventListener('change', () => {
            colorPattern = colorSel.value;
            updateCustomColorInputs();
        });
        speedRange.addEventListener('input', () => {
            speed = parseFloat(speedRange.value);
            speedVal.textContent = speed.toFixed(2);
        });
        // === Intensity/Brightness Control ===
        const intensityRange = document.getElementById('intensityRange');
        const intensityVal = document.getElementById('intensityVal');
        intensityRange.value = intensity;
        intensityVal.textContent = intensity.toFixed(2);
        intensityRange.addEventListener('input', () => {
            intensity = parseFloat(intensityRange.value);
            intensityVal.textContent = intensity.toFixed(2);
            spotLights.forEach(l => l.intensity = intensity);
        });
        // Set initial values in UI to match JS defaults
        numLightsInput.value = numLights;
        numLightsVal.textContent = numLights;
        patternSel.value = lightPattern;
        colorSel.value = colorPattern;
        speedRange.value = speed;
        speedVal.textContent = speed.toFixed(2);

        function updateCustomColorInputs() {
            if (colorSel.value === 'custom') {
                customColorsDiv.style.display = '';
                customColorsDiv.innerHTML = '';
                for (let i = 0; i < numLights; i++) {
                    const input = document.createElement('input');
                    input.type = 'color';
                    input.value = customColors[i] || '#ffffff';
                    input.style.marginRight = '6px';
                    input.addEventListener('input', (e) => {
                        customColors[i] = e.target.value;
                    });
                    customColorsDiv.appendChild(input);
                }
            } else {
                customColorsDiv.style.display = 'none';
            }
        }
        updateCustomColorInputs();
        // Ensure intensity is applied to all spotlights on startup and when lights are created
        spotLights.forEach(l => l.intensity = intensity);
    </script>
</body>

</html>